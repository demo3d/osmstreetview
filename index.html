<!DOCTYPE html> 

<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">

    <link   type="text/css" rel="stylesheet" href="styles/global.css" media="screen" />
    <link   type="text/css" rel="stylesheet" href="styles/leaflet.css" />
    <script type="text/javascript" src="leaflet.js"></script>
    <script type="text/javascript" src="metatile.js"></script>

	<script type="text/javascript" src="gl-matrix.js" ></script>
	<script type="text/javascript" src="glu.js" ></script>

    <script src="webgl-debug.js"></script>
    
	<script id="shader-fs" type="x-shader/x-fragment">
		precision mediump float;
        varying vec2 texCoordV;
        uniform sampler2D tex;
		void main(void) {
		    float dx = (texCoordV.s - 0.5)*2.0;
		    float dy = (texCoordV.t - 0.5)*2.0;
		    
		    float radiusSquared = dx*dx + dy*dy;
            if ( radiusSquared > 1.0)
                discard;

            float alpha = radiusSquared < 0.9 ? 1.0 : (1.0 - radiusSquared)*10.0;

            gl_FragColor = texture2D(tex, texCoordV.st);
            gl_FragColor[3] = clamp(alpha, 0.0, 1.0);
		        
		}
	</script>

	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 vertexPosition;
        attribute vec2 vertexTexCoords;  			
		
		uniform mat4 modelViewMatrix;
		uniform mat4 perspectiveMatrix;

        varying vec2 texCoordV;

		void main(void) {
			gl_Position = perspectiveMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);
			texCoordV = vertexTexCoords;
		}
	</script>

	
    <script type="text/javascript">
    
    function init()
    {
        map = L.map('map_div').setView([52.15, 11.63], 14); //global 

        map.on("click", onMapClick);

        /*L.tileLayer('http://ipsum4.rbuch703.de/osm/{z}/{x}/{y}.png', {
            attribution: 'OpenStreetMap',
            maxZoom: 19, minZoom:1
        }).addTo(map);*/
        L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'OpenStreetMap',
            maxZoom: 19, minZoom:1
        }).addTo(map);

        L.control.scale({imperial:false, position:"topright"}).addTo(map);
        
	    initGl();  //initialize webGL canvas
    }    
    
    function onMetaTileLoaded(metatile)
    {
        var tex = gl.createTexture();
        gl.activeTexture(gl.TEXTURE0);
                
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, metatile.canvas); //load texture data
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);                  //set zoom-in filter to linear interpolation
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);    //set zoom-out filter to linear interpolation between pixels and mipmap levels
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); // texCords are clamped 
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); // to range [0..1]
        gl.generateMipmap(gl.TEXTURE_2D);                                     // automatic mipmap generation
        
        // enable anisotropic filtering for this texture of available.
        // without anisotrophy, textures on triangles close to parallel to the view direction
        // would appear extremely blurry
        var ext = gl.getExtension("EXT_texture_filter_anisotropic"); //check for anisotropy support
        var max_anisotropy = gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        if (ext)
             gl.texParameterf(gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, max_anisotropy);

        textures[metatile.zoom] = tex;

        renderScene();
    }
    
    var position;
    var numTiles = 0;
    var textures = [];
    var vertices = [];
    var texCoords= [];
    
    function onMapClick(e)
    {
        position = e.latlng;
        // request OSM tiles for texturing
        for (var zoom = 13; zoom <= 19; zoom++)
        {
            tile = new MetaTile(e.latlng, zoom);
            tile.onload = onMetaTileLoaded;
        }
        
        //construct geometry (including texture coordinates) to render the tiles on
        var geometry = [];
        var tc = [];
        var tcPerTile = [0,0, 1,0, 1,1, 0,0, 1,1, 0,1];
        for (var zoom = 13; zoom <= 19; zoom++)
        {
            // formulas taken from http://wiki.openstreetmap.org/wiki/Zoom_levels 
            var earthCircumference = 2 * Math.PI * (6378.1 * 1000);
            var physicalTileLength = earthCircumference* Math.cos(position.lat/180*Math.PI) / Math.pow(2, zoom);
            
            var halfWidth = 0.5 * physicalTileLength;
            //tile rectangle, specified as two triangles
            geometry = geometry.concat([-halfWidth, -halfWidth, zoom/100,
                                         halfWidth, -halfWidth, zoom/100,
                                         halfWidth,  halfWidth, zoom/100,
                                        -halfWidth, -halfWidth, zoom/100,
                                         halfWidth,  halfWidth, zoom/100,
                                        -halfWidth,  halfWidth, zoom/100]);
            tc = tc.concat(tcPerTile);
        }
        
        
        vertices = glu.createArrayBuffer(geometry);
	    texCoords=glu.createArrayBuffer(tc);
	    textures = [];
        numTiles = geometry.length/(3*6); //six vertices per tile, three coordinates per vertex
        
    }   

			/**
			 * Initialises WebGL and creates the 3D scene.
			 */
	function initGl()
	{
		//register event handler
		webGlCanvas.onclick = renderScene;
		/*webGlCanvas.onmousedown = onMouseDown;
		webGlCanvas.onmouseup   = onMouseUp;
		webGlCanvas.onmouseout  = onMouseUp;
		webGlCanvas.onmousemove = onMouseMove;*/

        //create context
		gl = webGlCanvas.getContext("webgl") || webGlCanvas.getContext("experimental-webgl");
		if(!gl)
		{
			alert("Your browser does not support 3D views (WebGL)");
			return;
		}
		gl = WebGLDebugUtils.makeDebugContext(gl);
		
		gl.clearColor(136/255, 211/255, 239/255, 1.0);

		gl.clearDepth(1.0);
		gl.enable(gl.DEPTH_TEST);
		gl.depthFunc(gl.LEQUAL);
		
		gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        onResize();
		
		//compile and link shader program
		var vertexShader   = glu.compileShader( document.getElementById("shader-vs").text, gl.VERTEX_SHADER);
		var fragmentShader = glu.compileShader( document.getElementById("shader-fs").text, gl.FRAGMENT_SHADER);
		shaderProgram  = glu.createProgram( vertexShader, fragmentShader);
		gl.useProgram(shaderProgram);   //    Install the program as part of the current rendering state

        //get location of variables in shader program (to later bind them to values);
		shaderProgram.vertexPosAttribLocation = gl.getAttribLocation(shaderProgram, "vertexPosition"); 
		shaderProgram.texCoordAttribLocation = gl.getAttribLocation(shaderProgram, "vertexTexCoords"); 
        shaderProgram.modelViewMatrixLocation = gl.getUniformLocation(shaderProgram, "modelViewMatrix")
		shaderProgram.perspectiveMatrixLocation = gl.getUniformLocation(shaderProgram, "perspectiveMatrix");
		shaderProgram.texLocation = gl.getUniformLocation(shaderProgram, "tex");
	    
		gl.enableVertexAttribArray(shaderProgram.vertexPosAttribLocation); // setup vertex coordinate buffer
		gl.enableVertexAttribArray(shaderProgram.texCoordAttribLocation); //setup texcoord buffer
        gl.uniform1i(shaderProgram.texLocation, 0); //select texture unit 0 as the source for the shader variable "tex" 
		
        //view setup 
        eye = [0,0,20];
        lookDir = [-0.41759445514800125, 0.9086334100609345, 0];

        //setup projection matrix (model-view will be set up on a per-frame basis in renderScene() )
	    var projectionMatrix = mat4.create();
	    mat4.perspective(projectionMatrix, 45.0, webGlCanvas.width / webGlCanvas.height, 1.0, 10000.0);
        gl.uniformMatrix4fv(shaderProgram.perspectiveMatrixLocation, false, projectionMatrix);

        renderScene();
	}
	

	function onResize()
	{
	    webGlCanvas.height = webGlCanvas.clientHeight;
	    webGlCanvas.width  = webGlCanvas.clientWidth;
	    if (gl)
			gl.viewport(0, 0, webGlCanvas.width, webGlCanvas.height);
	}	
	
	function renderScene()
	{
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        //determine look-at point
	    var lookAt = vec3.create();
        vec3.add(lookAt, eye, lookDir);
	
		var modelViewMatrix = mat4.create();
		mat4.lookAt(modelViewMatrix, eye,  lookAt,[0, 0, 1]);
		mat4.scale(modelViewMatrix, modelViewMatrix, [1,-1,1]);//negate y coordinate to make positive y go downward
		gl.uniformMatrix4fv(shaderProgram.modelViewMatrixLocation, false, modelViewMatrix);

	
        gl.bindBuffer(gl.ARRAY_BUFFER, vertices);   //select the vertex buffer as the currrently active ARRAY_BUFFER (for subsequent calls)
		gl.vertexAttribPointer(shaderProgram.vertexPosAttribLocation, 3, gl.FLOAT, false, 0, 0);  //assigns array "vertices" bound above as the vertex attribute "vertexPosition"

		gl.bindBuffer(gl.ARRAY_BUFFER, texCoords);
		gl.vertexAttribPointer(shaderProgram.texCoordAttribLocation, 2, gl.FLOAT, false, 0, 0);  //assigns array "texCoords" bound above as the vertex attribute "vertexTexCoords"


        gl.activeTexture(gl.TEXTURE0);  //successive commands (here 'gl.bindTexture()') apply to texture unit 0
	    for (var i = 0; i < numTiles; i++)
	    {
	        gl.bindTexture(gl.TEXTURE_2D, textures[i+13]); //render geometry using texture "texture[i]" in texture unit 0
    	    gl.drawArrays(gl.TRIANGLES, i*6, 6);
	    }
		gl.flush();
	}
	
    </script>
    <title>Mietwohnungen in Magdeburg</title>
</head>

<body onload="init()"  > <!-- style ="padding: 0px; margin: 0px;" -->
<h2 style="text-align:center">OSM Street View</h2>

    <div id="map_div" style="width:400px; height:300px"> </div>

<div id="content" style="position:absolute; right:10px; top:50px; bottom:0px">

    <div id="nav" style="background-color:#EEE; position:fixed; width:66%; top:50px; bottom:0px; right: 0px; overflow-y:scroll">
		<canvas id="webGlCanvas" style="width:1024px; height:768px;background:black" ></canvas>


        <h3>Suchkriterien</h3>
        <div id="tile_div"> </div>
    </div>
</div> 


</body>


</html>
