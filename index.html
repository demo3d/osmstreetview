<!DOCTYPE html> 

<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">

    <link   type="text/css" rel="stylesheet" href="styles/global.css" media="screen" />
    <link   type="text/css" rel="stylesheet" href="styles/leaflet.css" />
    <script type="text/javascript" src="leaflet.js"></script>
    <script type="text/javascript" src="metatile.js"></script>
    <script type="text/javascript" src="mapLayer.js"></script>

	<script type="text/javascript" src="gl-matrix.js" ></script>
	<script type="text/javascript" src="glu.js" ></script>

    <script src="webgl-debug.js"></script>
    
	<script id="shader-fs" type="x-shader/x-fragment">
		precision mediump float;
        varying vec2 texCoordV;
        uniform sampler2D tex;
		void main(void) {
		    float dx = (texCoordV.s - 0.5)*2.0;
		    float dy = (texCoordV.t - 0.5)*2.0;
		    
		    float radiusSquared = dx*dx + dy*dy;
            if ( radiusSquared > 1.0)
                discard;

            float alpha = radiusSquared < 0.9 ? 1.0 : (1.0 - radiusSquared)*10.0;

            gl_FragColor = texture2D(tex, texCoordV.st);
            gl_FragColor[3] = clamp(alpha, 0.0, 1.0);
		        
		}
	</script>

	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 vertexPosition;
        attribute vec2 vertexTexCoords;  			
		
		uniform mat4 modelViewMatrix;
		uniform mat4 perspectiveMatrix;

        varying vec2 texCoordV;

		void main(void) {
			gl_Position = perspectiveMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);
			texCoordV = vertexTexCoords;
		}
	</script>

	
    <script type="text/javascript">
    
    function init()
    {
        map = L.map('map_div').setView([52.15, 11.63], 14); //global 

        map.on("click", onMapClick);

        /*L.tileLayer('http://ipsum4.rbuch703.de/osm/{z}/{x}/{y}.png', {
            attribution: 'OpenStreetMap',
            maxZoom: 19, minZoom:1
        }).addTo(map);*/
        L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'OpenStreetMap',
            maxZoom: 19, minZoom:1
        }).addTo(map);

        L.control.scale({imperial:false, position:"topright"}).addTo(map);
        
	    initGl();  //initialize webGL canvas

		//register event handlers
		webGlCanvas.onclick = renderScene;
		webGlCanvas.onmousedown = onMouseDown;
		webGlCanvas.onmouseup   = onMouseUp;
		webGlCanvas.onmouseout  = onMouseUp;
		webGlCanvas.onmousemove = onMouseMove;

    }    
    
    var mapPlane;
    
    function onMapClick(e)
    {
        mapPlane = new MapLayer(gl, e.latlng);
        mapPlane.onLoaded = renderScene;
        position = e.latlng;
        console.log("Setting map center to %o", position);
        
    }   

	var x,y;
    var down = false;	
    		
	function onMouseDown(e)
	{
	    if (e.button != 0) 
	        return;

	    x = e.clientX;
	    y = e.clientY;
	    down = true;
	}
	
	function onMouseUp(e)
	{
	    if (e.button != 0) 
	        return;
	    down = false;
	    //renderScene();
	}
	
    function onMouseMove(e)
	{
	   if (! down) return;
	   var dx = e.clientX - x;
	   var dy = e.clientY - y;
	   x = e.clientX;
	   y = e.clientY;
	   
	   var rotMat = mat4.create();
	   mat4.rotateZ(rotMat, rotMat, -dx/100);
	   vec3.transformMat4(lookDir, lookDir, rotMat);
	   
	   /*var tmp = vec3.create();
	   vec3.scale(tmp, lookDir, -dy);
	   vec3.add(eye, eye, tmp);*/
	   
	   renderScene();
	}	
	
	/**
	 * Initialises WebGL and creates the 3D scene.
	 */
	function initGl()
	{
        //create context
		gl = webGlCanvas.getContext("webgl") || webGlCanvas.getContext("experimental-webgl");
		if(!gl)
		{
			alert("Your browser does not support 3D views (WebGL)");
			return;
		}
		gl = WebGLDebugUtils.makeDebugContext(gl);
		
		gl.clearColor(136/255, 211/255, 239/255, 1.0);

		gl.clearDepth(1.0);
		gl.enable(gl.DEPTH_TEST);
		gl.depthFunc(gl.LEQUAL);
		
		gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        onResize();
		
		//compile and link shader program
		var vertexShader   = glu.compileShader( document.getElementById("shader-vs").text, gl.VERTEX_SHADER);
		var fragmentShader = glu.compileShader( document.getElementById("shader-fs").text, gl.FRAGMENT_SHADER);
		shaderProgram  = glu.createProgram( vertexShader, fragmentShader);
		gl.useProgram(shaderProgram);   //    Install the program as part of the current rendering state

        //get location of variables in shader program (to later bind them to values);
		shaderProgram.vertexPosAttribLocation = gl.getAttribLocation(shaderProgram, "vertexPosition"); 
		shaderProgram.texCoordAttribLocation = gl.getAttribLocation(shaderProgram, "vertexTexCoords"); 
        shaderProgram.modelViewMatrixLocation = gl.getUniformLocation(shaderProgram, "modelViewMatrix")
		shaderProgram.perspectiveMatrixLocation = gl.getUniformLocation(shaderProgram, "perspectiveMatrix");
		shaderProgram.texLocation = gl.getUniformLocation(shaderProgram, "tex");
	    
		gl.enableVertexAttribArray(shaderProgram.vertexPosAttribLocation); // setup vertex coordinate buffer
		gl.enableVertexAttribArray(shaderProgram.texCoordAttribLocation); //setup texcoord buffer
        gl.uniform1i(shaderProgram.texLocation, 0); //select texture unit 0 as the source for the shader variable "tex" 
		
        //view setup 
        eye = [0,0,20];
        lookDir = [-0.41759445514800125, 0.9086334100609345, 0];

        //setup projection matrix (model-view will be set up on a per-frame basis in renderScene() )
	    var projectionMatrix = mat4.create();
	    mat4.perspective(projectionMatrix, 45.0, webGlCanvas.width / webGlCanvas.height, 1.0, 10000.0);
        gl.uniformMatrix4fv(shaderProgram.perspectiveMatrixLocation, false, projectionMatrix);

        renderScene();
	}
	

	function onResize()
	{
	    webGlCanvas.height = webGlCanvas.clientHeight;
	    webGlCanvas.width  = webGlCanvas.clientWidth;
	    if (gl)
			gl.viewport(0, 0, webGlCanvas.width, webGlCanvas.height);
	}	
	
	function renderScene()
	{
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        //determine look-at point
	    var lookAt = vec3.create();
        vec3.add(lookAt, eye, lookDir);
	
		var modelViewMatrix = mat4.create();
		mat4.lookAt(modelViewMatrix, eye,  lookAt,[0, 0, 1]);
		mat4.scale(modelViewMatrix, modelViewMatrix, [1,-1,1]);//negate y coordinate to make positive y go downward
		gl.uniformMatrix4fv(shaderProgram.modelViewMatrixLocation, false, modelViewMatrix);
        
        if (mapPlane)
            mapPlane.render();
        
		gl.flush();
	}
	
    </script>
    <title>Mietwohnungen in Magdeburg</title>
</head>

<body onload="init()"  > <!-- style ="padding: 0px; margin: 0px;" -->
<h2 style="text-align:center">OSM Street View</h2>

    <div id="map_div" style="width:400px; height:300px"> </div>

<div id="content" style="position:absolute; right:10px; top:50px; bottom:0px">

    <div id="nav" style="background-color:#EEE; position:fixed; width:66%; top:50px; bottom:0px; right: 0px; overflow-y:scroll">
		<canvas id="webGlCanvas" style="width:1024px; height:768px;background:black" ></canvas>


        <h3>Suchkriterien</h3>
        <div id="tile_div"> </div>
    </div>
</div> 


</body>


</html>
