<!DOCTYPE html>
<html> 
	<head>
 
		<title>3D Apartment Tech Demo</title> 
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

		<script id="shader-fs" type="x-shader/x-fragment">
    		precision mediump float;
            varying vec2 texCoordV;
            uniform sampler2D tex;
    		void main(void) {
    		    
        		gl_FragColor = texture2D(tex, texCoordV.st) + vec4(0.1, 0.1, 0.1, 0.0);
        		//vec4(texCoordV.s, texCoordV.t , 0.0, 1.0);
    		}
		</script>

        <style media="screen" type="text/css" rel="stylesheet">
        body *{
            font-family: Verdana,Calibri,"Liberation Sans",Verdana,Arial,sans,sans-serif;}
            
        #notes p, #notes h3 { padding-left:5px; padding-right:5px;}
        #notes p {margin-top:10px; margin-bottom:10px}
        
        </style>

		<script id="shader-vs" type="x-shader/x-vertex">
  			attribute vec3 vertexPosition;
            attribute vec2 vertexTexCoords;  			
			
			uniform mat4 modelViewMatrix;
			uniform mat4 perspectiveMatrix;

            varying vec2 texCoordV;
 
 			void main(void) {
				gl_Position = perspectiveMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);
				texCoordV = vertexTexCoords;
  			}
		</script>
		<script type="text/javascript" src="loadLayout.js" ></script>
		<script type="text/javascript" src="gl-matrix.js" ></script>

		<script type="text/javascript">
			window.onload = init;
			
			glu = {};

			glu.compileShader = function (src_str, type)
			{
                var shader = gl.createShader(type); //create abstract shader object
                gl.shaderSource(shader, src_str);   //set its GLSL source
                gl.compileShader(shader);           //Compile it
                //    Check for errors
                if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
	                console.log("Couldn't compile the vertex shader: " + gl.getShaderInfoLog(shader) );
	                //    Clean up
	                gl.deleteShader(shader);
	                return null;
                }
                return shader;
			}
			
			glu.createProgram = function (vShader, fShader)
			{
                var shaderProgram = gl.createProgram();
				
				gl.attachShader(shaderProgram, vShader); 
				gl.attachShader(shaderProgram, fShader); 
				gl.linkProgram(shaderProgram);           
				if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
					alert("Unable to initialise shaders");
					//    Clean up
					gl.deleteProgram(shaderProgram);
					gl.deleteProgram(vertexShader);
					gl.deleteProgram(fragmentShader);
					return null;
				}			   
				return shaderProgram 
			}
		
			
			glu.createArrayBuffer = function(data)
			{
				    
			    var buffer = gl.createBuffer(); //    create a buffer to store our data in
			    gl.bindBuffer(gl.ARRAY_BUFFER, buffer); //    Bind the buffer object to the ARRAY_BUFFER target.
			    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW); //fill the bound array buffer
				return buffer;
			}
			
			function onResize()
			{
			    canvasGl.height = canvasGl.clientHeight;
			    canvasGl.width  = canvasGl.clientWidth;
			    if (gl)
    				gl.viewport(0, 0, canvasGl.width, canvasGl.height);
			}
			
			var numVertices = null;
			var textures = [];
			function renderScene()
			{
			    var lookAt = vec3.create();
                vec3.add(lookAt, eye, lookDir);
			
				var modelViewMatrix = mat4.create();//initialize to identity matrix;
				mat4.lookAt(modelViewMatrix, eye,  lookAt,[0, 0, 1]);
				mat4.scale(modelViewMatrix, modelViewMatrix, [1,-1,1]);//negate y coordinate to make positive y go downward
				gl.uniformMatrix4fv(shaderProgram.modelViewMatrixLocation, false, modelViewMatrix);

			
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				for (var i = 0; i < numVertices; i+=6)
				{
                    gl.activeTexture(gl.TEXTURE0);				
                    gl.bindTexture(gl.TEXTURE_2D, textures[i/6]);
				    gl.drawArrays(gl.TRIANGLES, i, 6);
			    }
				gl.flush();
			}
			
			var x,y;
            var down = false;			
			function onMouseDown(e)
			{
			    if (e.button != 0) 
			        return;

			    x = e.clientX;
			    y = e.clientY;
			    down = true;
			}
			
			function onMouseUp(e)
			{
			    if (e.button != 0) 
			        return;
			    down = false;
			    //renderScene();
			}
			
			function onMinimapMouseDown(e)
			{
			    var scale = Math.min( canvas2d.width / layoutImage.width, canvas2d.height / layoutImage.height);
			    console.log(e);
			    var x = e.clientX - canvas2d.offsetLeft;
			    var y = e.clientY - canvas2d.offsetTop;
			    eye[0] = x/scale;
			    eye[1] = -y/scale;
			    renderScene();
			    renderMiniMap();
			}
			
			function onMouseMove(e)
			{
			   if (! down) return;
			   var dx = e.clientX - x;
			   var dy = e.clientY - y;
			   x = e.clientX;
			   y = e.clientY;
			   
			   
			   var rotMat = mat4.create();
			   mat4.rotateZ(rotMat, rotMat, -dx/100);
			   vec3.transformMat4(lookDir, lookDir, rotMat);
			   
			   var tmp = vec3.create();
			   vec3.scale(tmp, lookDir, -dy);
			   vec3.add(eye, eye, tmp);
			   
			   renderScene();
			   renderMiniMap();
			}
			
            function handleLoadedTexture(texture) {
                //console.log("Handling loading of texture " + texture.image.src);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Prevents s-coordinate wrapping (repeating). Required for NPOT-textures
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); //Prevents t-coordinate wrapping (repeating). Required for NPOT-textures              
                gl.uniform1i(shaderProgram.samplerUniform, 0);

                textures[ texture.id] = texture;
                renderScene();
                //gl.bindTexture(gl.TEXTURE_2D, null);
              }

            /* scoping hack: needs to be a dedicated function, because it is
             *               called within a loop over j. Without a dedicated function,
             *               the 'texture' and "j" variable would be shared between all 
             *               loop iterations, leading to the same texture being loaded 
             *               over and over again */
			function requestTexture(j)
			{
                var texture = gl.createTexture();
                texture.id = j;
                texture.image = new Image();
                texture.image.onload = function() {
                  handleLoadedTexture(texture)
                }

                texture.image.src = "tiles/tile_"+j+".png";
		        return texture;
			}
			
			
			function processLayout(segments)
			{
			    var vertices = [];
			    var texCoords = [];
			    console.log("Processing Layout");
			    for (var i in segments)
			    {
			        var seg = segments[i];
			        /* D-C   
			         * |/|
			         * A-B  */
			        var A = segments[i].pos;
			        var w = segments[i].width;
			        var B = [A[0]+w[0], A[1]+w[1], A[2]+w[2]];
			        var h = segments[i].height;
			        var C = [B[0]+h[0], B[1]+h[1], B[2]+h[2]];
			        var D = [A[0]+h[0], A[1]+h[1], A[2]+h[2]];
			        vertices = vertices.concat(A, B, C);
			        vertices = vertices.concat(A, C, D);
			        
			        texCoords = texCoords.concat( [0,0], [1,0], [1,1]);
			        texCoords = texCoords.concat( [0,0], [1,1], [0,1]);
			    }

                numVertices = (vertices.length / 3) | 0;
			    
			    vertices = glu.createArrayBuffer(vertices); //convert to webgl array buffer
			    texCoords=glu.createArrayBuffer(texCoords);
			    
                gl.bindBuffer(gl.ARRAY_BUFFER, vertices);   //select the vertex buffer as the currrently active ARRAY_BUFFER (for subsequent calls)
				gl.vertexAttribPointer(shaderProgram.vertexPosAttribLocation, 3, gl.FLOAT, false, 0, 0);  //assigns the currently bound ARRAY_BUFFER to the vertex attribute at the passed index			    
				gl.bindBuffer(gl.ARRAY_BUFFER, texCoords);
				gl.vertexAttribPointer(shaderProgram.texCoordAttribLocation, 2, gl.FLOAT, false, 0, 0);  
								
			    for (var i = 0; i < numVertices/6; i++) {
			        requestTexture(i);
			    }
				
                renderScene();
                renderMiniMap();
			}
			
			/**
			 * Initialises WebGL and creates the 3D scene.
			 */
			function initGl()
			{
				canvasGl = document.getElementById("webGlCanvas");
				//register event handler
				canvasGl.onmousedown = onMouseDown;
				canvasGl.onmouseup   = onMouseUp;
				canvasGl.onmouseout  = onMouseUp;
				canvasGl.onmousemove = onMouseMove;

                //create context
				gl = canvasGl.getContext("webgl") || canvasGl.getContext("experimental-webgl");
				if(!gl)
				{
					alert("There's no WebGL context available.");
					return;
				}
				
				gl.clearColor(0.0, 0.5, 0.0, 1.0);
				gl.clearDepth(1.0);
				gl.enable(gl.DEPTH_TEST);
				gl.depthFunc(gl.LEQUAL);
				//gl.enable(gl.CULL_FACE);
                onResize();
				
				//compile and link shader program
				var vertexShader   = glu.compileShader( document.getElementById("shader-vs").text, gl.VERTEX_SHADER);
				var fragmentShader = glu.compileShader( document.getElementById("shader-fs").text, gl.FRAGMENT_SHADER);
				shaderProgram  = glu.createProgram( vertexShader, fragmentShader);
				gl.useProgram(shaderProgram);   //    Install the program as part of the current rendering state

                //get location of variables inshader program (to later bind them to values);
				shaderProgram.vertexPosAttribLocation = gl.getAttribLocation(shaderProgram, "vertexPosition"); 
				shaderProgram.texCoordAttribLocation = gl.getAttribLocation(shaderProgram, "vertexTexCoords"); 
                shaderProgram.modelViewMatrixLocation = gl.getUniformLocation(shaderProgram, "modelViewMatrix")
				shaderProgram.perspectiveMatrixLocation = gl.getUniformLocation(shaderProgram, "perspectiveMatrix");
			    
				gl.enableVertexAttribArray(shaderProgram.vertexPosAttribLocation); // setup vertex coordinate buffer
				gl.enableVertexAttribArray(shaderProgram.texCoordAttribLocation); //setup texcoord buffer

                //setup 
                eye = [393, -608, 120];
                lookDir = [-0.41759445514800125, 0.9086334100609345, 0];

                //setup projection matrix
			    var projectionMatrix = mat4.create();
			    mat4.perspective(projectionMatrix, 45.0, canvasGl.width / canvasGl.height, 1.0, 10000.0);
                gl.uniformMatrix4fv(shaderProgram.perspectiveMatrixLocation, false, projectionMatrix);

                layoutImage = new Image(); //global
                layoutImage.onload = function() { var tmp = loadLayout(this); processLayout(tmp);}
                layoutImage.src = "out.png";

			}
			
			function renderMiniMap()
			{
			    var scale = Math.min( canvas2d.width / layoutImage.width, canvas2d.height / layoutImage.height);
			    
			    context2d.drawImage(layoutImage, 0, 0, layoutImage.width*scale, layoutImage.height*scale);
			    //console.log(eye[0]*scale,eye[1]*scale);
			    context2d.lineWidth = 2;
			    context2d.strokeStyle = "#44D";
			    context2d.beginPath();
                context2d.arc(eye[0]*scale,-eye[1]*scale,5,0,2*Math.PI);
                context2d.stroke();

			    context2d.strokeStyle = "#D44";
			    context2d.beginPath();
                context2d.moveTo(eye[0]*scale,-eye[1]*scale);
                context2d.lineTo( eye[0] * scale + 10 * lookDir[0], - (eye[1] * scale + 10 * lookDir[1]) );
                context2d.stroke();
			    
			    

			}
			
			function initCanvas2d()
			{
			    canvas2d = document.getElementById("minimapCanvas");
			    canvas2d.height = canvas2d.clientHeight;
			    canvas2d.width  = canvas2d.clientWidth;
			    
			    canvas2d.onmousedown = onMinimapMouseDown;
			    
			    context2d = canvas2d.getContext("2d");
			}
			
			function init()
			{
			    initGl();
			    initCanvas2d();
			}
		</script>
	</head>
	<body>
	<div id="content" style="position:absolute; right:10px; top:50px; bottom:0px"></div>

	
		<canvas id="minimapCanvas" style="position:absolute; left:10px; top:300px; width:277px; height:300px" ></canvas>
		<div id="notes" style="position:absolute; left:10px; top:0px; width:275px;">
		    <h3>3D Apartment Tech Demo</h3>
		    <p>This page demonstrates how a browser-based 3D view could help you get a feeling for the layout of an apartment you are about to rent.</p>
		    <p>Navigate around in the apartment by clicking and dragging on the 3D view.</p>
		</div>
		<canvas id="webGlCanvas" style="position:absolute; left:310px; top:0px; width:800px; height:600px" ></canvas>
		
		<div class="placeholder" style="height:600px"> </div>
        <h3>Comments</h3>
	    <p>I'd love to hear how you like the page, so please leave a note in the comments section.</p>

        <div id="disqus_thread" style="width:800px"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'rbuch703de'; // required: replace example with your forum shortname

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
	</body>
</html> 
